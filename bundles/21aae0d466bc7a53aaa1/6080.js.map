{"version":3,"file":"bundles/21aae0d466bc7a53aaa1/6080.js","mappings":"yoCAqCO,IAAKA,EAAW,SAAXA,GAAW,OAAXA,EAAW,8BAAXA,EAAW,4BAAXA,EAAW,0BAAXA,EAAW,0BAAXA,EAAW,0BAAXA,EAAW,6CAAXA,EAAW,4BAAXA,CAAW,MAwEhB,MAAMC,EAQT,aAAWC,GAAgC,IAAAC,EACvC,OAAmB,QAAnBA,EAAOC,KAAKC,eAAO,IAAAF,OAAA,EAAZA,EAAcG,cACzB,CAQOC,WAAAA,CACcF,EACAG,EACAC,EACVC,IACTC,EAAAA,EAAAA,GAAA,0BAAAA,EAAAA,EAAAA,GAAA,sBAAAA,EAAAA,EAAAA,GAAA,yCAJmBN,QAAAA,EAA6B,KAC7BG,YAAAA,EAAoB,KACpBC,OAAAA,EAAqB,KAC/BC,UAAAA,EAEPN,KAAKQ,UAAYH,EAASI,EAAAA,WAAWC,YAAcD,EAAAA,WAAWE,KAClE,CAKA,QAAWC,GACP,OAAOZ,KAAKa,KAChB,CAKA,kBAAaC,GACLd,KAAKa,QAILb,KAAKQ,YAAcC,EAAAA,WAAWC,aAAeV,KAAKK,OAClDL,KAAKa,YAAcb,KAAKC,QAAQa,aAAad,KAAKQ,UAAWR,KAAKK,OAAOU,aAClEf,KAAKQ,YAAcC,EAAAA,WAAWE,QACrCX,KAAKa,YAAcb,KAAKC,QAAQa,aAAad,KAAKQ,YAE1D,CAKA,oBAAWQ,GACP,OAAOhB,KAAKQ,YAAcC,EAAAA,WAAWC,WACzC,CAKA,eAAWO,GACP,OAAQjB,KAAKgB,gBACjB,CAQA,wBAAaE,GAIT,GAHAC,EAAAA,EAAOC,KAAK,kCAAkCpB,KAAKiB,2BAA2BjB,KAAKI,sBAC7EJ,KAAKC,QAAQoB,UAEfrB,KAAKI,YAGL,GAAIJ,KAAKiB,iBAEF,KAAAK,EAEH,IAAIC,EACJ,IACI,MAAM,OAAEC,SAAiBxB,KAAKK,OAAQoB,gBACtCF,QAAyBG,EAAAA,EAAAA,IAAuCF,EACpE,CAAE,MAAOG,GACLR,EAAAA,EAAOS,MAAM,mCAAoCD,EACrD,CAEA,GAAoB,QAApBL,EAAIC,SAAgB,IAAAD,IAAhBA,EAAkBO,SAASC,sBAAsBC,SAASC,EAAAA,IAW1D,YAJMhC,KAAKiC,KAAqB,CAC5BC,KAAMtC,EAAYuC,QAClBC,OAAQC,EAAqBC,sBAE3B,IAAIC,EACN,gCACAF,EAAqBC,2BAZnBtC,KAAKiC,KAAuB,CAC9BC,KAAMtC,EAAY4C,UAClBC,UAAW,CAAC,8BACZC,WAAY1C,KAAKK,OAAQU,aAYrC,MACG,GAAIf,KAAKiB,YAAa,CAEzBE,EAAAA,EAAOC,KAAK,iCACZ,MAAMuB,QAAgB3C,KAAK4C,UAE3B,IAAID,aAAO,EAAPA,EAAST,QAAStC,EAAYuC,QAC9B,MAAM,IAAII,EAAgB,SAAUI,EAAQP,QAGhD,IAAIO,aAAO,EAAPA,EAAST,QAAStC,EAAY4C,UAK9B,YAJMxC,KAAKiC,KAAqB,CAC5BC,KAAMtC,EAAYuC,QAClBC,OAAQC,EAAqBQ,4BAE3B,IAAIN,EACN,8BACAF,EAAqBQ,2BAI7B,MAAO,CAAEC,WAAYH,EAAQD,WACjC,CAGA,MAAO,CAAC,CACZ,CAOA,8BAAaK,GAIT,GAAI/C,KAAKiB,YACL,MAAM,IAAI+B,MAAM,wDACb,CAIH7B,EAAAA,EAAOC,KAAK,gCACZ,MAAMuB,QAAgB3C,KAAK4C,UAE3B,IAAID,aAAO,EAAPA,EAAST,QAAStC,EAAYuC,QAC9B,MAAM,IAAII,EAAgB,SAAUI,EAAQP,QAGhD,IAAIO,aAAO,EAAPA,EAAST,QAAStC,EAAYqD,SAK9B,YAJMjD,KAAKiC,KAAqB,CAC5BC,KAAMtC,EAAYuC,QAClBC,OAAQC,EAAqBQ,4BAE3B,IAAIN,EACN,8BACAF,EAAqBQ,2BAI7B,GAtMZ,SACIF,GAEA,MAA4B,+BAArBA,EAAQO,QACnB,CAkMgBC,CAA0CR,GAAU,CACpD,MAAQS,2BAA4BC,EAAKC,UAAWC,GAAyBZ,GACrEa,iBAAkBC,EAAiBC,0BAA2BC,GAA4BN,EAElG,IAAIO,GAAsB,EAC1B,IAAI,IAAAC,QACiB,QAAjBA,EAAM7D,KAAKK,cAAM,IAAAwD,OAAA,EAAXA,EAAaC,UAAUP,GACjC,CAAE,MAAOQ,GACDA,aAAeC,EAAAA,IAAkC,MAAnBD,EAAIE,aAClCL,GAAsB,EAE9B,CAEA,GAAIA,EAKA,YAJM5D,KAAKiC,KAAqB,CAC5BC,KAAMtC,EAAYuC,QAClBC,OAAQC,EAAqB6B,sBAE3B,IAAI3B,EACN,qCACAF,EAAqB6B,qBAM7B,OAFAlE,KAAKuD,qBAAuBA,EAErB,CAAEE,gBAAiBE,QAAAA,EAA2BF,EACzD,CAMA,YAJMzD,KAAKiC,KAAqB,CAC5BC,KAAMtC,EAAYuC,QAClBC,OAAQC,EAAqBC,sBAE3B,IAAIC,EACN,iDACAF,EAAqBC,oBAE7B,CACJ,CAMA,kBAAa6B,GACT,GAAInE,KAAKiB,YAAa,OACZjB,KAAKiC,KAAqB,CAC5BC,KAAMtC,EAAYwE,UAGtBjD,EAAAA,EAAOC,KAAK,+BACZ,MAAMuB,QAAgB3C,KAAK4C,UAC3B,IAAID,aAAO,EAAPA,EAAST,QAAStC,EAAYuC,QAC9B,MAAM,IAAII,EAAgB,SAAUI,EAAQP,QAGhD,IAAIO,aAAO,EAAPA,EAAST,QAAStC,EAAYyE,QAK9B,YAJMrE,KAAKiC,KAAqB,CAC5BC,KAAMtC,EAAYuC,QAClBC,OAAQC,EAAqBQ,4BAE3B,IAAIN,EACN,8BACAF,EAAqBQ,2BAG7B,MAAO,CAAEyB,QAAS3B,EAEtB,CAAO,CACH,IAAK3C,KAAKuD,qBACN,MAAM,IAAIP,MAAM,mCAEdhD,KAAKiC,KAAsB,CAC7BC,KAAMtC,EAAY2E,mBAGtBpD,EAAAA,EAAOC,KAAK,+BACZ,MAAMuB,QAAgB3C,KAAK4C,UAE3B,IAAID,aAAO,EAAPA,EAAST,QAAStC,EAAYuC,QAC9B,MAAM,IAAII,EAAgB,SAAUI,EAAQP,QAGhD,IAAIO,aAAO,EAAPA,EAAST,QAAStC,EAAY4E,SAC9B,MAAM,IAAIjC,EAAgB,gBAAiBkC,EAA8BC,cAG7E,IAAI/B,aAAO,EAAPA,EAAST,QAAStC,EAAYwE,QAK9B,YAJMpE,KAAKiC,KAAqB,CAC5BC,KAAMtC,EAAYuC,QAClBC,OAAQC,EAAqBQ,4BAE3B,IAAIN,EAAgB,qBAAsBF,EAAqBQ,2BAGzE,MAAM8B,EAAUC,KAAKC,MAAQ,IAC7B,EAAG,CAEC,IAAI,IAAAC,EAGA,SAFgC,QAAjBA,EAAM9E,KAAKK,cAAM,IAAAyE,OAAA,EAAXA,EAAahB,UAAU9D,KAAKuD,uBAErC,CAER,MAAMwB,QAAsB/E,KAAKK,OAAQ2E,YAAaC,sBACtD,GAAIjF,KAAKC,QAAQiF,UACb,MAAM,IAAI3C,EAAgB,iBAAkBF,EAAqB8C,eAOrE,aAJMnF,KAAKiC,KAAImD,EAAA,CACXlD,KAAMtC,EAAYyE,SACfU,IAEA,CAAET,QAASS,EAEtB,CACJ,CAAE,MAAOhB,GACL,KAAIA,aAAeC,EAAAA,IAAkC,MAAnBD,EAAIE,YAGlC,MAAMF,CAEd,OACMsB,EAAAA,EAAAA,IAAM,IAChB,OAAST,KAAKC,MAAQF,GAMtB,YAJM3E,KAAKiC,KAAqB,CAC5BC,KAAMtC,EAAYuC,QAClBC,OAAQC,EAAqBiD,iBAE3B,IAAI/C,EAAgB,uBAAwBF,EAAqBiD,eAC3E,CACJ,CAEA,aAAc1C,GACV,aAAc5C,KAAKC,QAAQsF,eAC/B,CAEA,UAActD,CAA+BU,SACnC3C,KAAKC,QAAQuF,WAAW7C,EAClC,CAKA,kCAAa8C,GACT,IAAKzF,KAAKgB,iBACN,MAAM,IAAIgC,MAAM,mDAEdhD,KAAKiC,KAAqB,CAC5BC,KAAMtC,EAAYuC,QAClBC,OAAQC,EAAqB8C,eAErC,CAMA,YAAaO,CAAOtD,GAA6E,IAAAuD,EAC/E,QAAdA,EAAA3F,KAAKM,iBAAS,IAAAqF,GAAdA,EAAAC,KAAA5F,KAAiBoC,SACXpC,KAAKC,QAAQyF,OAAOtD,EAC9B,CAKA,WAAayD,SACH7F,KAAKC,QAAQ4F,OACvB,ECxaG,MAAMtD,UAAwBS,MAC1B7C,WAAAA,CACH2F,EACgBlF,GAEhBmF,MAAMD,GAAS,KAFClF,KAAAA,CAGpB,ECJG,IAAKyB,EAAoB,SAApBA,GAAoB,OAApBA,EAAoB,6CAApBA,EAAoB,4CAApBA,EAAoB,kCAApBA,EAAoB,wDAApBA,EAAoB,2CAApBA,EAAoB,+BAApBA,CAAoB,MASpBoC,EAA6B,SAA7BA,GAA6B,OAA7BA,EAA6B,kBAA7BA,EAA6B,kDAA7BA,EAA6B,oDAA7BA,EAA6B,2BAA7BA,EAA6B,oDAA7BA,EAA6B,4DAA7BA,EAA6B,kBAA7BA,EAA6B,6BAA7BA,EAA6B,2BAA7BA,CAA6B,MCb7BuB,EAAgB,SAAhBA,GAAgB,OAAhBA,EAAgB,kCAAhBA,EAAgB,yDAAhBA,CAAgB,M,sDCWrB,MAAMC,EAgCF9F,WAAAA,EAAY,QACf+F,EAAO,UACP5F,EAAS,IACT6F,EAAG,OACH9F,EAAM,iBACN+F,KAOD7F,EAAAA,EAAAA,GAAA,oBAAAA,EAAAA,EAAAA,GAAA,uBAAAA,EAAAA,EAAAA,GAAA,iCAAAA,EAAAA,EAAAA,GAAA,wBAAAA,EAAAA,EAAAA,GAAA,0BAAAA,EAAAA,EAAAA,GAAA,qBAAAA,EAAAA,EAAAA,GAAA,0BAAAA,EAAAA,EAAAA,GAAA,6BAAAA,EAAAA,EAAAA,GAAA,mBAnCkB,IAAKA,EAAAA,EAAAA,GAAA,eACT,GAmCbP,KAAKkG,QAAUA,EACflG,KAAKM,UAAYA,EACjBN,KAAKK,OAASA,EACdL,KAAKoG,iBAAmBA,EACxBpG,KAAKmG,IAAMA,CACf,CAKA,SAAWE,GACP,OAAOrG,KAAKsG,MAChB,CAKA,aAAWpB,GACP,OAAOlF,KAAKuG,UAChB,CAEQC,KAAAA,CAAMC,EAAwBC,GAClC,OAAI1G,KAAKkG,QACElG,KAAKkG,QAAQO,EAAUC,GAE3BC,WAAWH,MAAMC,EAAUC,EACtC,CAEA,qBAAcE,GACV,GAAI5G,KAAKK,OACL,IACI,SAAUL,KAAKK,OAAOwG,iCAAiC,sBACnD,OAAO7G,KAAKK,OAAOyG,KACdC,OAAO,sCAAkCC,EAAWC,EAAAA,GAAaC,UACjEC,UAEb,CAAE,MAAOpD,GACL5C,EAAAA,EAAOiG,KAAK,kCAAmCrD,EACnD,CAGJ,OAAO/D,KAAKoG,gBAChB,CAMA,UAAanE,CAAKoF,GAA6B,IAAAC,EAAAC,EAC3C,GAAIvH,KAAKuG,WACL,OAEJ,MAAMiB,EAASxH,KAAKmG,IAAMsB,EAAAA,OAAOC,IAAMD,EAAAA,OAAOE,KACxCC,EAAc,QAAXN,EAAGtH,KAAKmG,WAAG,IAAAmB,EAAAA,QAAWtH,KAAK4G,kBAEpC,IAAKgB,EACD,MAAM,IAAI5E,MAAM,0BAGpB,MAAM6E,EAAkC,CAAE,eAAgB,eAGrD7H,KAAK8H,MAAQ9H,KAAKmG,WACbnG,KAAK4C,UAGX5C,KAAK8H,OACLD,EAAQ,YAAc7H,KAAK8H,MAG/B3G,EAAAA,EAAOC,KAAK,MAAMoG,KAAUI,UAAYP,eAAkBrH,KAAK8H,QAE/D,MAAMC,QAAY/H,KAAKwG,MAAMoB,EAAK,CAAEJ,SAAQK,UAASG,KAAMX,EAAMY,SAAU,WAC3E,GAAmB,MAAfF,EAAIG,OACJ,OAAOlI,KAAK0F,OAAOjB,EAA8B0D,SAMrD,GAJAnI,KAAK8H,KAA8B,QAA1BP,EAAGQ,EAAIF,QAAQO,IAAI,eAAO,IAAAb,EAAAA,OAAIP,EAEvC7F,EAAAA,EAAOC,KAAK,kBAAkBpB,KAAK8H,QAE/BN,IAAWC,EAAAA,OAAOE,KAAM,CACxB,MAAMU,EAAUN,EAAIF,QAAQO,IAAI,WAC5BC,IACIrI,KAAKsI,eACLC,aAAavI,KAAKsI,cAClBtI,KAAKsI,kBAAetB,GAExBhH,KAAKwI,UAAY,IAAI5D,KAAKyD,GAC1BrI,KAAKsI,aAAeG,YAAW,KAC3BzI,KAAKsI,kBAAetB,EACpBhH,KAAK0F,OAAOjB,EAA8BiE,QAAQ,GACnD1I,KAAKwI,UAAUG,UAAY/D,KAAKC,QAGvC,MAAM+D,QAAab,EAAIa,OACvB,GAAwB,iBAAbA,EAAKzC,IACZ,MAAM,IAAInD,MAAM,2BAEpBhD,KAAKmG,IAAMyC,EAAKzC,IAChBnG,KAAKsG,QAAS,CAClB,CACJ,CAMA,aAAa1D,GACT,IAAK5C,KAAKmG,IACN,MAAM,IAAInD,MAAM,yBAGpB,OAAa,KAAA6F,EACT,GAAI7I,KAAKuG,WACL,OAGJ,MAAMsB,EAAkC,CAAC,EACrC7H,KAAK8H,OACLD,EAAQ,iBAAmB7H,KAAK8H,MAGpC3G,EAAAA,EAAOC,KAAK,UAAUpB,KAAKmG,sBAAsBnG,KAAK8H,QACtD,MAAMgB,QAAa9I,KAAKwG,MAAMxG,KAAKmG,IAAK,CAAEqB,OAAQC,EAAAA,OAAOsB,IAAKlB,YAE9D,GAAoB,MAAhBiB,EAAKZ,OAEL,kBADMlI,KAAK0F,OAAOjB,EAA8B0D,SAMpD,MAAML,EAA+B,QAA3Be,EAAGC,EAAKjB,QAAQO,IAAI,eAAO,IAAAS,EAAAA,OAAI7B,EACzC,GAAyC,eAArC8B,EAAKjB,QAAQO,IAAI,gBACjBpI,KAAK8H,KAAOA,OACT,GAAoB,MAAhBgB,EAAKZ,OAAgB,CAC5B,IAAKJ,EAID,kBADM9H,KAAK0F,OAAOjB,EAA8BuE,aAIpDhJ,KAAK8H,KAAOA,EACZ,MAAMmB,QAAaH,EAAKG,OAExB,OADA9H,EAAAA,EAAOC,KAAK,aAAa6H,eAAkBjJ,KAAK8H,QACzCmB,CACX,OACM5D,EAAAA,EAAAA,IAAM,IAChB,CACJ,CAOA,YAAaK,CAAOtD,GAA6E,IAAAuD,EACzF3F,KAAKuG,aACLvG,KAAKsI,eACLC,aAAavI,KAAKsI,cAClBtI,KAAKsI,kBAAetB,GAIpB5E,IAAWqC,EAA8B0D,SACzCnI,KAAKwI,WACLxI,KAAKwI,UAAUG,UAAY/D,KAAKC,QAEhCzC,EAASqC,EAA8BiE,SAG3C1I,KAAKuG,YAAa,EAClBvG,KAAKsG,QAAS,EACA,QAAdX,EAAA3F,KAAKM,iBAAS,IAAAqF,GAAdA,EAAAC,KAAA5F,KAAiBoC,GAEbA,IAAWqC,EAA8BC,cAAgBtC,IAAWC,EAAqB8C,qBACnFnF,KAAK6F,QAEnB,CAKA,WAAaA,GAMT,GALI7F,KAAKsI,eACLC,aAAavI,KAAKsI,cAClBtI,KAAKsI,kBAAetB,GAGnBhH,KAAKmG,IACV,UACUnG,KAAKwG,MAAMxG,KAAKmG,IAAK,CAAEqB,OAAQC,EAAAA,OAAOyB,QAChD,CAAE,MAAOvH,GACLR,EAAAA,EAAOiG,KAAKzF,EAChB,CACJ,ECpOG,MAAMwH,EAKFhJ,WAAAA,CACKiJ,EACAC,EACD/I,IACTC,EAAAA,EAAAA,GAAA,8BAAAA,EAAAA,EAAAA,GAAA,mCAAAA,EAAAA,EAAAA,GAAA,kBANkB,GAAK,KAGb6I,kBAAAA,EAA2C,KAC3CC,eAAAA,EAAoC,KACrC/I,UAAAA,EAEPN,KAAKsJ,cAAgB,IAAIC,EAAAA,KAC7B,CASA,kBAAazI,CAAa0I,EAAkB1G,GACxC,MAAM,IAAEqD,GAAQnG,KAAKoJ,kBAErB,IAAKjD,EACD,MAAM,IAAInD,MAAM,6BAGpB,OAAO,IAAIyG,EAAAA,WACPzJ,KAAKsJ,cAAcI,aACnBvD,EACAqD,IAAS/I,EAAAA,WAAWC,YAAcoC,OAAakE,GACjD2C,SACN,CAKOzJ,YAAAA,GAAmC,IAAA0J,EACtC,MAAMC,EAA2B,QAA1BD,EAAG5J,KAAK8J,0BAAkB,IAAAF,OAAA,EAAvBA,EAAyBG,aAEnC,GAAKF,EAGL,OAAOG,MAAMC,KAAKJ,EAAEK,YACfC,KAAKC,GAAM,GAAGA,EAAI,KAClBC,KAAK,GACd,CAKA,aAAahJ,GACT,GAAIrB,KAAKsK,UACL,MAAM,IAAItH,MAAM,6BAGpB,GAAIhD,KAAKqJ,eAAgB,CAErB,MAAMkB,EAASvK,KAAKsJ,cAAckB,2BAC9BxK,KAAKqJ,eACL,iCAEJrJ,KAAK8J,mBAAqBS,EAAOtK,QAa7BkB,EAAAA,EAAOC,KAAK,sCACNpB,KAAKoJ,kBAAkBnH,KAAKsI,EAAOE,iBAc7C,CACItJ,EAAAA,EAAOC,KAAK,8BACZ,MAAMsJ,QAAmB1K,KAAKoJ,kBAAkBxG,UAEhD,IAAK8H,EACD,MAAM,IAAInI,EACN,gCACAF,EAAqBQ,2BAK7B,GAAgC,kCAFM7C,KAAK2K,QAAQD,GAG/C,MAAM,IAAInI,EACN,qCACAkC,EAA8BmG,wBAK1C,CACJ,KAAO,CAYHzJ,EAAAA,EAAOC,KAAK,oCACZ,MAAMyJ,QAA6B7K,KAAKoJ,kBAAkBxG,UAC1D,IAAKiI,EACD,MAAM,IAAI7H,MAAM,iCAGpB,MAAM,QAAE/C,EAAS6F,QAASgF,GACtB9K,KAAKsJ,cAAcyB,0BAA0BF,GAGjD,GAFA7K,KAAK8J,mBAAqB7J,EAEY,kCAAlC6K,EACA,MAAM,IAAIvI,EACN,qCACAkC,EAA8BmG,yBAGtCzJ,EAAAA,EAAOC,KAAK,iCAEZD,EAAAA,EAAOC,KAAK,0BACZ,MAAM4J,QAAuBhL,KAAKiL,QAAQ,iCACpCjL,KAAKoJ,kBAAkBnH,KAAK+I,EAKtC,CAEAhL,KAAKsK,WAAY,CACrB,CAEA,aAAcK,CAAQD,GAClB,IAAK1K,KAAK8J,mBACN,MAAM,IAAI9G,MAAM,kBAGpB,OAAOhD,KAAK8J,mBAAmBa,QAAQD,EAC3C,CAEA,aAAcO,CAAQC,GAClB,IAAKlL,KAAK8J,mBACN,MAAM,IAAI9G,MAAM,kBAGpB,OAAOhD,KAAK8J,mBAAmBmB,QAAQC,EAC3C,CAMA,gBAAa1F,CAAqC7C,GAC9C,IAAK3C,KAAKsK,UACN,MAAM,IAAItH,MAAM,kBAGpB,MAAMmI,EAAqBC,KAAKC,UAAU1I,GAC1CxB,EAAAA,EAAOmK,MAAM,eAAeF,KAAKC,UAAU1I,EAAQT,qBAE7ClC,KAAKoJ,kBAAkBnH,WAAWjC,KAAKiL,QAAQE,GACzD,CAKA,mBAAa5F,GACT,IAAKvF,KAAK8J,mBACN,MAAM,IAAI9G,MAAM,kBAGpB,MAAM0H,QAAmB1K,KAAKoJ,kBAAkBxG,UAChD,IAAK8H,EACD,OAEJ,MAAMQ,QAAkBlL,KAAK2K,QAAQD,GAC/B9B,EAAOwC,KAAKG,MAAML,GAGxB,OADA/J,EAAAA,EAAOmK,MAAM,eAAeF,KAAKC,UAAUzC,EAAK1G,eACzC0G,CACX,CAKA,WAAa/C,SACH7F,KAAKoJ,kBAAkBvD,OACjC,CAMA,YAAaH,CAAOtD,GAChB,IAAI,IAAAuD,QACM3F,KAAKoJ,kBAAkB1D,OAAOtD,GACtB,QAAduD,EAAA3F,KAAKM,iBAAS,IAAAqF,GAAdA,EAAAC,KAAA5F,KAAiBoC,EACrB,CAAE,cACQpC,KAAK6F,OACf,CACJ,CAKA,aAAWX,GACP,OAAOlF,KAAKoJ,kBAAkBlE,SAClC,E,4iCC3OJ,MAAMsG,EAA8BA,EAAGC,SAAQC,eAC7CC,EAAAA,EAAAA,KAAC,OACCC,UAAWC,EACX,cAAY,OACZ,cAAaJ,EAAS,QAAK,EAC3B,gBAAeC,EAAW,QAAK,IAatBI,GAAWC,EAAAA,EAAAA,aAAW,SAASC,EAE1CC,GACA,IAFA,UAAEL,EAAA,OAAWM,EAAS,GAAYF,EAANG,GAAAC,EAAAA,EAAAA,GAAAJ,EAAAK,GAG5B,MAAMC,EAAUC,EAAWV,EAAkBD,IACtCY,EAAeC,GAAoBC,EAAAA,SAAe,IAClDC,EAAWC,GAAgBF,EAAAA,SAChC,MAGIG,EAAUC,IAAkD,IAAAC,EAChE,MAAMC,EAAQF,EAAMG,cACHR,EAAM,QAANM,EAAAC,EAAME,aAAA,IAAAH,OAAA,EAANA,EAAab,QAG5BiB,SAASC,gBAAkBJ,GACF,OAAzBA,EAAMK,gBACiB,OAAvBL,EAAMM,aAENV,EAAa,MAEbA,EAAa,CAACI,EAAMK,eAAgBL,EAAMM,cAAa,EAKzD,OAAAC,EAAAA,EAAAA,MAAC,MAAI,CAAA3B,UAAWU,EACdkB,SAAA,EAAA7B,EAAAA,EAAAA,KAAC,QAAAvG,EAAAA,EAAA,GACK+G,GAAA,IACJsB,UAAU,UAIVvL,KAAK,OACLwL,UAAW,EACXC,UAAWzB,EACXN,UAAWC,EACX+B,QAAS,OAAO1B,KAChB2B,aAAa,gBACbC,SAAUjB,EACVkB,QAASlB,EACTmB,OAAQnB,EACRoB,YAAapB,EACbqB,YAAarB,EACbsB,UAAWtB,EACXuB,SAAUvB,EACVZ,SAEDjC,MAAMC,KAAKD,MAAMkC,GAAQmC,QAAQlE,KAAKmE,IACrC3C,EAAAA,EAAAA,KAACH,EAAA,CAECC,OAAQ6C,EAAQ9B,EAChBd,WACIiB,GAAa2B,GAAS3B,EAAU,IAAM2B,EAAQ3B,EAAU,IAHvD2B,OASf,G","sources":["webpack://element-web/./node_modules/matrix-js-sdk/src/rendezvous/MSC4108SignInWithQR.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/rendezvous/RendezvousError.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/rendezvous/RendezvousFailureReason.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/rendezvous/RendezvousIntent.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/rendezvous/transports/MSC4108RendezvousSession.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/rendezvous/channels/MSC4108SecureChannel.ts","webpack://element-web/../../../../../src/components/Form/Controls/MFA/MFA.tsx"],"sourcesContent":["/*\nCopyright 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { QrCodeMode } from \"@matrix-org/matrix-sdk-crypto-wasm\";\n\nimport {\n    ClientRendezvousFailureReason,\n    MSC4108FailureReason,\n    RendezvousError,\n    RendezvousFailureListener,\n} from \"./index.ts\";\nimport { MatrixClient } from \"../client.ts\";\nimport { logger } from \"../logger.ts\";\nimport { MSC4108SecureChannel } from \"./channels/MSC4108SecureChannel.ts\";\nimport { MatrixError } from \"../http-api/index.ts\";\nimport { sleep } from \"../utils.ts\";\nimport { DEVICE_CODE_SCOPE, discoverAndValidateOIDCIssuerWellKnown, OidcClientConfig } from \"../oidc/index.ts\";\nimport { CryptoApi } from \"../crypto-api/index.ts\";\n\n/**\n * Enum representing the payload types transmissible over [MSC4108](https://github.com/matrix-org/matrix-spec-proposals/pull/4108)\n * secure channels.\n * @experimental Note that this is UNSTABLE and may have breaking changes without notice.\n */\nexport enum PayloadType {\n    Protocols = \"m.login.protocols\",\n    Protocol = \"m.login.protocol\",\n    Failure = \"m.login.failure\",\n    Success = \"m.login.success\",\n    Secrets = \"m.login.secrets\",\n    ProtocolAccepted = \"m.login.protocol_accepted\",\n    Declined = \"m.login.declined\",\n}\n\n/**\n * Type representing the base payload format for [MSC4108](https://github.com/matrix-org/matrix-spec-proposals/pull/4108)\n * messages sent over the secure channel.\n * @experimental Note that this is UNSTABLE and may have breaking changes without notice.\n */\nexport interface MSC4108Payload {\n    type: PayloadType;\n}\n\ninterface ProtocolsPayload extends MSC4108Payload {\n    type: PayloadType.Protocols;\n    protocols: string[];\n    homeserver: string;\n}\n\ninterface ProtocolPayload extends MSC4108Payload {\n    type: PayloadType.Protocol;\n    protocol: Exclude<string, \"device_authorization_grant\">;\n    device_id: string;\n}\n\ninterface DeviceAuthorizationGrantProtocolPayload extends ProtocolPayload {\n    protocol: \"device_authorization_grant\";\n    device_authorization_grant: {\n        verification_uri: string;\n        verification_uri_complete?: string;\n    };\n}\n\nfunction isDeviceAuthorizationGrantProtocolPayload(\n    payload: ProtocolPayload,\n): payload is DeviceAuthorizationGrantProtocolPayload {\n    return payload.protocol === \"device_authorization_grant\";\n}\n\ninterface FailurePayload extends MSC4108Payload {\n    type: PayloadType.Failure;\n    reason: MSC4108FailureReason;\n    homeserver?: string;\n}\n\ninterface DeclinedPayload extends MSC4108Payload {\n    type: PayloadType.Declined;\n}\n\ninterface SuccessPayload extends MSC4108Payload {\n    type: PayloadType.Success;\n}\n\ninterface AcceptedPayload extends MSC4108Payload {\n    type: PayloadType.ProtocolAccepted;\n}\n\ninterface SecretsPayload extends MSC4108Payload, Awaited<ReturnType<NonNullable<CryptoApi[\"exportSecretsBundle\"]>>> {\n    type: PayloadType.Secrets;\n}\n\n/**\n * Prototype of the unstable [MSC4108](https://github.com/matrix-org/matrix-spec-proposals/pull/4108)\n * sign in with QR + OIDC flow.\n * @experimental Note that this is UNSTABLE and may have breaking changes without notice.\n */\nexport class MSC4108SignInWithQR {\n    private readonly ourIntent: QrCodeMode;\n    private _code?: Uint8Array;\n    private expectingNewDeviceId?: string;\n\n    /**\n     * Returns the check code for the secure channel or undefined if not generated yet.\n     */\n    public get checkCode(): string | undefined {\n        return this.channel?.getCheckCode();\n    }\n\n    /**\n     * @param channel - The secure channel used for communication\n     * @param client - The Matrix client in used on the device already logged in\n     * @param didScanCode - Whether this side of the channel scanned the QR code from the other party\n     * @param onFailure - Callback for when the rendezvous fails\n     */\n    public constructor(\n        private readonly channel: MSC4108SecureChannel,\n        private readonly didScanCode: boolean,\n        private readonly client?: MatrixClient,\n        public onFailure?: RendezvousFailureListener,\n    ) {\n        this.ourIntent = client ? QrCodeMode.Reciprocate : QrCodeMode.Login;\n    }\n\n    /**\n     * Returns the code representing the rendezvous suitable for rendering in a QR code or undefined if not generated yet.\n     */\n    public get code(): Uint8Array | undefined {\n        return this._code;\n    }\n\n    /**\n     * Generate the code including doing partial set up of the channel where required.\n     */\n    public async generateCode(): Promise<void> {\n        if (this._code) {\n            return;\n        }\n\n        if (this.ourIntent === QrCodeMode.Reciprocate && this.client) {\n            this._code = await this.channel.generateCode(this.ourIntent, this.client.getDomain()!);\n        } else if (this.ourIntent === QrCodeMode.Login) {\n            this._code = await this.channel.generateCode(this.ourIntent);\n        }\n    }\n\n    /**\n     * Returns true if the device is the already logged in device reciprocating a new login on the other side of the channel.\n     */\n    public get isExistingDevice(): boolean {\n        return this.ourIntent === QrCodeMode.Reciprocate;\n    }\n\n    /**\n     * Returns true if the device is the new device logging in being reciprocated by the device on the other side of the channel.\n     */\n    public get isNewDevice(): boolean {\n        return !this.isExistingDevice;\n    }\n\n    /**\n     * The first step in the OIDC QR login process.\n     * To be called after the QR code has been rendered or scanned.\n     * The scanning device has to discover the homeserver details, if they scanned the code then they already have it.\n     * If the new device is the one rendering the QR code then it has to wait be sent the homeserver details via the rendezvous channel.\n     */\n    public async negotiateProtocols(): Promise<{ serverName?: string }> {\n        logger.info(`negotiateProtocols(isNewDevice=${this.isNewDevice} didScanCode=${this.didScanCode})`);\n        await this.channel.connect();\n\n        if (this.didScanCode) {\n            // Secure Channel step 6 completed, we trust the channel\n\n            if (this.isNewDevice) {\n                // MSC4108-Flow: ExistingScanned - take homeserver from QR code which should already be set\n            } else {\n                // MSC4108-Flow: NewScanned -send protocols message\n                let oidcClientConfig: OidcClientConfig | undefined;\n                try {\n                    const { issuer } = await this.client!.getAuthIssuer();\n                    oidcClientConfig = await discoverAndValidateOIDCIssuerWellKnown(issuer);\n                } catch (e) {\n                    logger.error(\"Failed to discover OIDC metadata\", e);\n                }\n\n                if (oidcClientConfig?.metadata.grant_types_supported.includes(DEVICE_CODE_SCOPE)) {\n                    await this.send<ProtocolsPayload>({\n                        type: PayloadType.Protocols,\n                        protocols: [\"device_authorization_grant\"],\n                        homeserver: this.client!.getDomain()!,\n                    });\n                } else {\n                    await this.send<FailurePayload>({\n                        type: PayloadType.Failure,\n                        reason: MSC4108FailureReason.UnsupportedProtocol,\n                    });\n                    throw new RendezvousError(\n                        \"Device code grant unsupported\",\n                        MSC4108FailureReason.UnsupportedProtocol,\n                    );\n                }\n            }\n        } else if (this.isNewDevice) {\n            // MSC4108-Flow: ExistingScanned - wait for protocols message\n            logger.info(\"Waiting for protocols message\");\n            const payload = await this.receive<ProtocolsPayload>();\n\n            if (payload?.type === PayloadType.Failure) {\n                throw new RendezvousError(\"Failed\", payload.reason);\n            }\n\n            if (payload?.type !== PayloadType.Protocols) {\n                await this.send<FailurePayload>({\n                    type: PayloadType.Failure,\n                    reason: MSC4108FailureReason.UnexpectedMessageReceived,\n                });\n                throw new RendezvousError(\n                    \"Unexpected message received\",\n                    MSC4108FailureReason.UnexpectedMessageReceived,\n                );\n            }\n\n            return { serverName: payload.homeserver };\n        } else {\n            // MSC4108-Flow: NewScanned - nothing to do\n        }\n        return {};\n    }\n\n    /**\n     * The second & third step in the OIDC QR login process.\n     * To be called after `negotiateProtocols` for the existing device.\n     * To be called after OIDC negotiation for the new device. (Currently unsupported)\n     */\n    public async deviceAuthorizationGrant(): Promise<{\n        verificationUri?: string;\n        userCode?: string;\n    }> {\n        if (this.isNewDevice) {\n            throw new Error(\"New device flows around OIDC are not yet implemented\");\n        } else {\n            // The user needs to do step 7 for the out-of-band confirmation\n            // but, first we receive the protocol chosen by the other device so that\n            // the confirmation_uri is ready to go\n            logger.info(\"Waiting for protocol message\");\n            const payload = await this.receive<ProtocolPayload | DeviceAuthorizationGrantProtocolPayload>();\n\n            if (payload?.type === PayloadType.Failure) {\n                throw new RendezvousError(\"Failed\", payload.reason);\n            }\n\n            if (payload?.type !== PayloadType.Protocol) {\n                await this.send<FailurePayload>({\n                    type: PayloadType.Failure,\n                    reason: MSC4108FailureReason.UnexpectedMessageReceived,\n                });\n                throw new RendezvousError(\n                    \"Unexpected message received\",\n                    MSC4108FailureReason.UnexpectedMessageReceived,\n                );\n            }\n\n            if (isDeviceAuthorizationGrantProtocolPayload(payload)) {\n                const { device_authorization_grant: dag, device_id: expectingNewDeviceId } = payload;\n                const { verification_uri: verificationUri, verification_uri_complete: verificationUriComplete } = dag;\n\n                let deviceAlreadyExists = true;\n                try {\n                    await this.client?.getDevice(expectingNewDeviceId);\n                } catch (err: MatrixError | unknown) {\n                    if (err instanceof MatrixError && err.httpStatus === 404) {\n                        deviceAlreadyExists = false;\n                    }\n                }\n\n                if (deviceAlreadyExists) {\n                    await this.send<FailurePayload>({\n                        type: PayloadType.Failure,\n                        reason: MSC4108FailureReason.DeviceAlreadyExists,\n                    });\n                    throw new RendezvousError(\n                        \"Specified device ID already exists\",\n                        MSC4108FailureReason.DeviceAlreadyExists,\n                    );\n                }\n\n                this.expectingNewDeviceId = expectingNewDeviceId;\n\n                return { verificationUri: verificationUriComplete ?? verificationUri };\n            }\n\n            await this.send<FailurePayload>({\n                type: PayloadType.Failure,\n                reason: MSC4108FailureReason.UnsupportedProtocol,\n            });\n            throw new RendezvousError(\n                \"Received a request for an unsupported protocol\",\n                MSC4108FailureReason.UnsupportedProtocol,\n            );\n        }\n    }\n\n    /**\n     * The fifth (and final) step in the OIDC QR login process.\n     * To be called after the new device has completed authentication.\n     */\n    public async shareSecrets(): Promise<{ secrets?: Omit<SecretsPayload, \"type\"> }> {\n        if (this.isNewDevice) {\n            await this.send<SuccessPayload>({\n                type: PayloadType.Success,\n            });\n            // then wait for secrets\n            logger.info(\"Waiting for secrets message\");\n            const payload = await this.receive<SecretsPayload>();\n            if (payload?.type === PayloadType.Failure) {\n                throw new RendezvousError(\"Failed\", payload.reason);\n            }\n\n            if (payload?.type !== PayloadType.Secrets) {\n                await this.send<FailurePayload>({\n                    type: PayloadType.Failure,\n                    reason: MSC4108FailureReason.UnexpectedMessageReceived,\n                });\n                throw new RendezvousError(\n                    \"Unexpected message received\",\n                    MSC4108FailureReason.UnexpectedMessageReceived,\n                );\n            }\n            return { secrets: payload };\n            // then done?\n        } else {\n            if (!this.expectingNewDeviceId) {\n                throw new Error(\"No new device ID expected\");\n            }\n            await this.send<AcceptedPayload>({\n                type: PayloadType.ProtocolAccepted,\n            });\n\n            logger.info(\"Waiting for outcome message\");\n            const payload = await this.receive<SuccessPayload | DeclinedPayload>();\n\n            if (payload?.type === PayloadType.Failure) {\n                throw new RendezvousError(\"Failed\", payload.reason);\n            }\n\n            if (payload?.type === PayloadType.Declined) {\n                throw new RendezvousError(\"User declined\", ClientRendezvousFailureReason.UserDeclined);\n            }\n\n            if (payload?.type !== PayloadType.Success) {\n                await this.send<FailurePayload>({\n                    type: PayloadType.Failure,\n                    reason: MSC4108FailureReason.UnexpectedMessageReceived,\n                });\n                throw new RendezvousError(\"Unexpected message\", MSC4108FailureReason.UnexpectedMessageReceived);\n            }\n\n            const timeout = Date.now() + 10000; // wait up to 10 seconds\n            do {\n                // is the device visible via the Homeserver?\n                try {\n                    const device = await this.client?.getDevice(this.expectingNewDeviceId);\n\n                    if (device) {\n                        // if so, return the secrets\n                        const secretsBundle = await this.client!.getCrypto()!.exportSecretsBundle!();\n                        if (this.channel.cancelled) {\n                            throw new RendezvousError(\"User cancelled\", MSC4108FailureReason.UserCancelled);\n                        }\n                        // send secrets\n                        await this.send<SecretsPayload>({\n                            type: PayloadType.Secrets,\n                            ...secretsBundle,\n                        });\n                        return { secrets: secretsBundle };\n                        // let the other side close the rendezvous session\n                    }\n                } catch (err: MatrixError | unknown) {\n                    if (err instanceof MatrixError && err.httpStatus === 404) {\n                        // not found, so keep waiting until timeout\n                    } else {\n                        throw err;\n                    }\n                }\n                await sleep(1000);\n            } while (Date.now() < timeout);\n\n            await this.send<FailurePayload>({\n                type: PayloadType.Failure,\n                reason: MSC4108FailureReason.DeviceNotFound,\n            });\n            throw new RendezvousError(\"New device not found\", MSC4108FailureReason.DeviceNotFound);\n        }\n    }\n\n    private async receive<T extends MSC4108Payload>(): Promise<T | FailurePayload | undefined> {\n        return (await this.channel.secureReceive()) as T | undefined;\n    }\n\n    private async send<T extends MSC4108Payload>(payload: T): Promise<void> {\n        await this.channel.secureSend(payload);\n    }\n\n    /**\n     * Decline the login on the existing device.\n     */\n    public async declineLoginOnExistingDevice(): Promise<void> {\n        if (!this.isExistingDevice) {\n            throw new Error(\"Can only decline login on existing device\");\n        }\n        await this.send<FailurePayload>({\n            type: PayloadType.Failure,\n            reason: MSC4108FailureReason.UserCancelled,\n        });\n    }\n\n    /**\n     * Cancels the rendezvous session.\n     * @param reason the reason for the cancellation\n     */\n    public async cancel(reason: MSC4108FailureReason | ClientRendezvousFailureReason): Promise<void> {\n        this.onFailure?.(reason);\n        await this.channel.cancel(reason);\n    }\n\n    /**\n     * Closes the rendezvous session.\n     */\n    public async close(): Promise<void> {\n        await this.channel.close();\n    }\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { RendezvousFailureReason } from \"./index.ts\";\n\nexport class RendezvousError extends Error {\n    public constructor(\n        message: string,\n        public readonly code: RendezvousFailureReason,\n    ) {\n        super(message);\n    }\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport type RendezvousFailureListener = (reason: RendezvousFailureReason) => void;\n\nexport type RendezvousFailureReason = MSC4108FailureReason | ClientRendezvousFailureReason;\n\nexport enum MSC4108FailureReason {\n    AuthorizationExpired = \"authorization_expired\",\n    DeviceAlreadyExists = \"device_already_exists\",\n    DeviceNotFound = \"device_not_found\",\n    UnexpectedMessageReceived = \"unexpected_message_received\",\n    UnsupportedProtocol = \"unsupported_protocol\",\n    UserCancelled = \"user_cancelled\",\n}\n\nexport enum ClientRendezvousFailureReason {\n    /** The sign in request has expired */\n    Expired = \"expired\",\n    /** The homeserver is lacking support for the required features */\n    HomeserverLacksSupport = \"homeserver_lacks_support\",\n    /** The secure channel verification failed meaning that it might be compromised */\n    InsecureChannelDetected = \"insecure_channel_detected\",\n    /** An invalid/incompatible QR code was scanned */\n    InvalidCode = \"invalid_code\",\n    /** The other device is not signed in */\n    OtherDeviceNotSignedIn = \"other_device_not_signed_in\",\n    /** The other device is already signed in */\n    OtherDeviceAlreadySignedIn = \"other_device_already_signed_in\",\n    /** Other */\n    Unknown = \"unknown\",\n    /** The user declined the sign in request */\n    UserDeclined = \"user_declined\",\n    /** The rendezvous request is missing an ETag header */\n    ETagMissing = \"etag_missing\",\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport enum RendezvousIntent {\n    LOGIN_ON_NEW_DEVICE = \"login.start\",\n    RECIPROCATE_LOGIN_ON_EXISTING_DEVICE = \"login.reciprocate\",\n}\n","/*\nCopyright 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { logger } from \"../../logger.ts\";\nimport { sleep } from \"../../utils.ts\";\nimport { ClientRendezvousFailureReason, MSC4108FailureReason, RendezvousFailureListener } from \"../index.ts\";\nimport { MatrixClient, Method } from \"../../matrix.ts\";\nimport { ClientPrefix } from \"../../http-api/index.ts\";\n\n/**\n * Prototype of the unstable [MSC4108](https://github.com/matrix-org/matrix-spec-proposals/pull/4108)\n * insecure rendezvous session protocol.\n * @experimental Note that this is UNSTABLE and may have breaking changes without notice.\n */\nexport class MSC4108RendezvousSession {\n    public url?: string;\n    private readonly client?: MatrixClient;\n    private readonly fallbackRzServer?: string;\n    private readonly fetchFn?: typeof globalThis.fetch;\n    private readonly onFailure?: RendezvousFailureListener;\n    private etag?: string;\n    private expiresAt?: Date;\n    private expiresTimer?: ReturnType<typeof setTimeout>;\n    private _cancelled = false;\n    private _ready = false;\n\n    public constructor({\n        onFailure,\n        url,\n        fetchFn,\n    }: {\n        fetchFn?: typeof globalThis.fetch;\n        onFailure?: RendezvousFailureListener;\n        url: string;\n    });\n    public constructor({\n        onFailure,\n        client,\n        fallbackRzServer,\n        fetchFn,\n    }: {\n        fetchFn?: typeof globalThis.fetch;\n        onFailure?: RendezvousFailureListener;\n        client?: MatrixClient;\n        fallbackRzServer?: string;\n    });\n    public constructor({\n        fetchFn,\n        onFailure,\n        url,\n        client,\n        fallbackRzServer,\n    }: {\n        fetchFn?: typeof globalThis.fetch;\n        onFailure?: RendezvousFailureListener;\n        url?: string;\n        client?: MatrixClient;\n        fallbackRzServer?: string;\n    }) {\n        this.fetchFn = fetchFn;\n        this.onFailure = onFailure;\n        this.client = client;\n        this.fallbackRzServer = fallbackRzServer;\n        this.url = url;\n    }\n\n    /**\n     * Returns whether the channel is ready to be used.\n     */\n    public get ready(): boolean {\n        return this._ready;\n    }\n\n    /**\n     * Returns whether the channel has been cancelled.\n     */\n    public get cancelled(): boolean {\n        return this._cancelled;\n    }\n\n    private fetch(resource: URL | string, options?: RequestInit): ReturnType<typeof globalThis.fetch> {\n        if (this.fetchFn) {\n            return this.fetchFn(resource, options);\n        }\n        return globalThis.fetch(resource, options);\n    }\n\n    private async getPostEndpoint(): Promise<string | undefined> {\n        if (this.client) {\n            try {\n                if (await this.client.doesServerSupportUnstableFeature(\"org.matrix.msc4108\")) {\n                    return this.client.http\n                        .getUrl(\"/org.matrix.msc4108/rendezvous\", undefined, ClientPrefix.Unstable)\n                        .toString();\n                }\n            } catch (err) {\n                logger.warn(\"Failed to get unstable features\", err);\n            }\n        }\n\n        return this.fallbackRzServer;\n    }\n\n    /**\n     * Sends data via the rendezvous channel.\n     * @param data the payload to send\n     */\n    public async send(data: string): Promise<void> {\n        if (this._cancelled) {\n            return;\n        }\n        const method = this.url ? Method.Put : Method.Post;\n        const uri = this.url ?? (await this.getPostEndpoint());\n\n        if (!uri) {\n            throw new Error(\"Invalid rendezvous URI\");\n        }\n\n        const headers: Record<string, string> = { \"content-type\": \"text/plain\" };\n\n        // if we didn't create the rendezvous channel, we need to fetch the first etag if needed\n        if (!this.etag && this.url) {\n            await this.receive();\n        }\n\n        if (this.etag) {\n            headers[\"if-match\"] = this.etag;\n        }\n\n        logger.info(`=> ${method} ${uri} with ${data} if-match: ${this.etag}`);\n\n        const res = await this.fetch(uri, { method, headers, body: data, redirect: \"follow\" });\n        if (res.status === 404) {\n            return this.cancel(ClientRendezvousFailureReason.Unknown);\n        }\n        this.etag = res.headers.get(\"etag\") ?? undefined;\n\n        logger.info(`Received etag: ${this.etag}`);\n\n        if (method === Method.Post) {\n            const expires = res.headers.get(\"expires\");\n            if (expires) {\n                if (this.expiresTimer) {\n                    clearTimeout(this.expiresTimer);\n                    this.expiresTimer = undefined;\n                }\n                this.expiresAt = new Date(expires);\n                this.expiresTimer = setTimeout(() => {\n                    this.expiresTimer = undefined;\n                    this.cancel(ClientRendezvousFailureReason.Expired);\n                }, this.expiresAt.getTime() - Date.now());\n            }\n            // MSC4108: we expect a JSON response with a rendezvous URL\n            const json = await res.json();\n            if (typeof json.url !== \"string\") {\n                throw new Error(\"No rendezvous URL given\");\n            }\n            this.url = json.url;\n            this._ready = true;\n        }\n    }\n\n    /**\n     * Receives data from the rendezvous channel.\n     * @return the returned promise won't resolve until new data is acquired or the channel is closed either by the server or the other party.\n     */\n    public async receive(): Promise<string | undefined> {\n        if (!this.url) {\n            throw new Error(\"Rendezvous not set up\");\n        }\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (this._cancelled) {\n                return undefined;\n            }\n\n            const headers: Record<string, string> = {};\n            if (this.etag) {\n                headers[\"if-none-match\"] = this.etag;\n            }\n\n            logger.info(`=> GET ${this.url} if-none-match: ${this.etag}`);\n            const poll = await this.fetch(this.url, { method: Method.Get, headers });\n\n            if (poll.status === 404) {\n                await this.cancel(ClientRendezvousFailureReason.Unknown);\n                return undefined;\n            }\n\n            // rely on server expiring the channel rather than checking ourselves\n\n            const etag = poll.headers.get(\"etag\") ?? undefined;\n            if (poll.headers.get(\"content-type\") !== \"text/plain\") {\n                this.etag = etag;\n            } else if (poll.status === 200) {\n                if (!etag) {\n                    // Some browsers & extensions block the ETag header for anti-tracking purposes\n                    // We try and detect this so the client can give the user a somewhat helpful message\n                    await this.cancel(ClientRendezvousFailureReason.ETagMissing);\n                    return undefined;\n                }\n\n                this.etag = etag;\n                const text = await poll.text();\n                logger.info(`Received: ${text} with etag ${this.etag}`);\n                return text;\n            }\n            await sleep(1000);\n        }\n    }\n\n    /**\n     * Cancels the rendezvous channel.\n     * If the reason is user_declined or user_cancelled then the channel will also be closed.\n     * @param reason the reason to cancel with\n     */\n    public async cancel(reason: MSC4108FailureReason | ClientRendezvousFailureReason): Promise<void> {\n        if (this._cancelled) return;\n        if (this.expiresTimer) {\n            clearTimeout(this.expiresTimer);\n            this.expiresTimer = undefined;\n        }\n\n        if (\n            reason === ClientRendezvousFailureReason.Unknown &&\n            this.expiresAt &&\n            this.expiresAt.getTime() < Date.now()\n        ) {\n            reason = ClientRendezvousFailureReason.Expired;\n        }\n\n        this._cancelled = true;\n        this._ready = false;\n        this.onFailure?.(reason);\n\n        if (reason === ClientRendezvousFailureReason.UserDeclined || reason === MSC4108FailureReason.UserCancelled) {\n            await this.close();\n        }\n    }\n\n    /**\n     * Closes the rendezvous channel.\n     */\n    public async close(): Promise<void> {\n        if (this.expiresTimer) {\n            clearTimeout(this.expiresTimer);\n            this.expiresTimer = undefined;\n        }\n\n        if (!this.url) return;\n        try {\n            await this.fetch(this.url, { method: Method.Delete });\n        } catch (e) {\n            logger.warn(e);\n        }\n    }\n}\n","/*\nCopyright 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n    Curve25519PublicKey,\n    Ecies,\n    EstablishedEcies,\n    QrCodeData,\n    QrCodeMode,\n} from \"@matrix-org/matrix-sdk-crypto-wasm\";\n\nimport {\n    ClientRendezvousFailureReason,\n    MSC4108FailureReason,\n    MSC4108Payload,\n    RendezvousError,\n    RendezvousFailureListener,\n} from \"../index.ts\";\nimport { MSC4108RendezvousSession } from \"../transports/MSC4108RendezvousSession.ts\";\nimport { logger } from \"../../logger.ts\";\n\n/**\n * Prototype of the unstable [MSC4108](https://github.com/matrix-org/matrix-spec-proposals/pull/4108)\n * secure rendezvous session protocol.\n * @experimental Note that this is UNSTABLE and may have breaking changes without notice.\n * Imports @matrix-org/matrix-sdk-crypto-wasm so should be async-imported to avoid bundling the WASM into the main bundle.\n */\nexport class MSC4108SecureChannel {\n    private readonly secureChannel: Ecies;\n    private establishedChannel?: EstablishedEcies;\n    private connected = false;\n\n    public constructor(\n        private rendezvousSession: MSC4108RendezvousSession,\n        private theirPublicKey?: Curve25519PublicKey,\n        public onFailure?: RendezvousFailureListener,\n    ) {\n        this.secureChannel = new Ecies();\n    }\n\n    /**\n     * Generate a QR code for the current session.\n     * @param mode the mode to generate the QR code in, either `Login` or `Reciprocate`.\n     * @param serverName the name of the homeserver to connect to, as defined by server discovery in the spec, required for `Reciprocate` mode.\n     */\n    public async generateCode(mode: QrCodeMode.Login): Promise<Uint8Array>;\n    public async generateCode(mode: QrCodeMode.Reciprocate, serverName: string): Promise<Uint8Array>;\n    public async generateCode(mode: QrCodeMode, serverName?: string): Promise<Uint8Array> {\n        const { url } = this.rendezvousSession;\n\n        if (!url) {\n            throw new Error(\"No rendezvous session URL\");\n        }\n\n        return new QrCodeData(\n            this.secureChannel.public_key(),\n            url,\n            mode === QrCodeMode.Reciprocate ? serverName : undefined,\n        ).toBytes();\n    }\n\n    /**\n     * Returns the check code for the secure channel or undefined if not generated yet.\n     */\n    public getCheckCode(): string | undefined {\n        const x = this.establishedChannel?.check_code();\n\n        if (!x) {\n            return undefined;\n        }\n        return Array.from(x.as_bytes())\n            .map((b) => `${b % 10}`)\n            .join(\"\");\n    }\n\n    /**\n     * Connects and establishes a secure channel with the other device.\n     */\n    public async connect(): Promise<void> {\n        if (this.connected) {\n            throw new Error(\"Channel already connected\");\n        }\n\n        if (this.theirPublicKey) {\n            // We are the scanning device\n            const result = this.secureChannel.establish_outbound_channel(\n                this.theirPublicKey,\n                \"MATRIX_QR_CODE_LOGIN_INITIATE\",\n            );\n            this.establishedChannel = result.channel;\n\n            /*\n             Secure Channel step 4. Device S sends the initial message\n\n             Nonce := 0\n             SH := ECDH(Ss, Gp)\n             EncKey := HKDF_SHA256(SH, \"MATRIX_QR_CODE_LOGIN|\" || Gp || \"|\" || Sp, 0, 32)\n             TaggedCiphertext := ChaCha20Poly1305_Encrypt(EncKey, Nonce, \"MATRIX_QR_CODE_LOGIN_INITIATE\")\n             Nonce := Nonce + 2\n             LoginInitiateMessage := UnpaddedBase64(TaggedCiphertext) || \"|\" || UnpaddedBase64(Sp)\n             */\n            {\n                logger.info(\"Sending LoginInitiateMessage\");\n                await this.rendezvousSession.send(result.initial_message);\n            }\n\n            /*\n            Secure Channel step 6. Verification by Device S\n\n            Nonce_G := 1\n            (TaggedCiphertext, Sp) := Unpack(Message)\n            Plaintext := ChaCha20Poly1305_Decrypt(EncKey, Nonce_G, TaggedCiphertext)\n            Nonce_G := Nonce_G + 2\n\n            unless Plaintext == \"MATRIX_QR_CODE_LOGIN_OK\":\n                FAIL\n             */\n            {\n                logger.info(\"Waiting for LoginOkMessage\");\n                const ciphertext = await this.rendezvousSession.receive();\n\n                if (!ciphertext) {\n                    throw new RendezvousError(\n                        \"No response from other device\",\n                        MSC4108FailureReason.UnexpectedMessageReceived,\n                    );\n                }\n                const candidateLoginOkMessage = await this.decrypt(ciphertext);\n\n                if (candidateLoginOkMessage !== \"MATRIX_QR_CODE_LOGIN_OK\") {\n                    throw new RendezvousError(\n                        \"Invalid response from other device\",\n                        ClientRendezvousFailureReason.InsecureChannelDetected,\n                    );\n                }\n\n                // Step 6 is now complete. We trust the channel\n            }\n        } else {\n            /*\n            Secure Channel step 5. Device G confirms\n\n            Nonce_S := 0\n            (TaggedCiphertext, Sp) := Unpack(LoginInitiateMessage)\n            SH := ECDH(Gs, Sp)\n            EncKey := HKDF_SHA256(SH, \"MATRIX_QR_CODE_LOGIN|\" || Gp || \"|\" || Sp, 0, 32)\n            Plaintext := ChaCha20Poly1305_Decrypt(EncKey, Nonce_S, TaggedCiphertext)\n            Nonce_S := Nonce_S + 2\n             */\n            // wait for the other side to send us their public key\n            logger.info(\"Waiting for LoginInitiateMessage\");\n            const loginInitiateMessage = await this.rendezvousSession.receive();\n            if (!loginInitiateMessage) {\n                throw new Error(\"No response from other device\");\n            }\n\n            const { channel, message: candidateLoginInitiateMessage } =\n                this.secureChannel.establish_inbound_channel(loginInitiateMessage);\n            this.establishedChannel = channel;\n\n            if (candidateLoginInitiateMessage !== \"MATRIX_QR_CODE_LOGIN_INITIATE\") {\n                throw new RendezvousError(\n                    \"Invalid response from other device\",\n                    ClientRendezvousFailureReason.InsecureChannelDetected,\n                );\n            }\n            logger.info(\"LoginInitiateMessage received\");\n\n            logger.info(\"Sending LoginOkMessage\");\n            const loginOkMessage = await this.encrypt(\"MATRIX_QR_CODE_LOGIN_OK\");\n            await this.rendezvousSession.send(loginOkMessage);\n\n            // Step 5 is complete. We don't yet trust the channel\n\n            // next step will be for the user to confirm the check code on the other device\n        }\n\n        this.connected = true;\n    }\n\n    private async decrypt(ciphertext: string): Promise<string> {\n        if (!this.establishedChannel) {\n            throw new Error(\"Channel closed\");\n        }\n\n        return this.establishedChannel.decrypt(ciphertext);\n    }\n\n    private async encrypt(plaintext: string): Promise<string> {\n        if (!this.establishedChannel) {\n            throw new Error(\"Channel closed\");\n        }\n\n        return this.establishedChannel.encrypt(plaintext);\n    }\n\n    /**\n     * Sends a payload securely to the other device.\n     * @param payload the payload to encrypt and send\n     */\n    public async secureSend<T extends MSC4108Payload>(payload: T): Promise<void> {\n        if (!this.connected) {\n            throw new Error(\"Channel closed\");\n        }\n\n        const stringifiedPayload = JSON.stringify(payload);\n        logger.debug(`=> {\"type\": ${JSON.stringify(payload.type)}, ...}`);\n\n        await this.rendezvousSession.send(await this.encrypt(stringifiedPayload));\n    }\n\n    /**\n     * Receives an encrypted payload from the other device and decrypts it.\n     */\n    public async secureReceive<T extends MSC4108Payload>(): Promise<Partial<T> | undefined> {\n        if (!this.establishedChannel) {\n            throw new Error(\"Channel closed\");\n        }\n\n        const ciphertext = await this.rendezvousSession.receive();\n        if (!ciphertext) {\n            return undefined;\n        }\n        const plaintext = await this.decrypt(ciphertext);\n        const json = JSON.parse(plaintext);\n\n        logger.debug(`<= {\"type\": ${JSON.stringify(json.type)}, ...}`);\n        return json as Partial<T> | undefined;\n    }\n\n    /**\n     * Closes the secure channel.\n     */\n    public async close(): Promise<void> {\n        await this.rendezvousSession.close();\n    }\n\n    /**\n     * Cancels the secure channel.\n     * @param reason the reason for the cancellation\n     */\n    public async cancel(reason: MSC4108FailureReason | ClientRendezvousFailureReason): Promise<void> {\n        try {\n            await this.rendezvousSession.cancel(reason);\n            this.onFailure?.(reason);\n        } finally {\n            await this.close();\n        }\n    }\n\n    /**\n     * Returns whether the rendezvous session has been cancelled.\n     */\n    public get cancelled(): boolean {\n        return this.rendezvousSession.cancelled;\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\nCopyright 2023 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport React, {\n  ComponentProps,\n  ComponentRef,\n  forwardRef,\n  PropsWithoutRef,\n} from \"react\";\n\nimport styles from \"./MFA.module.css\";\nimport classNames from \"classnames\";\nimport { Control } from \"@radix-ui/react-form\";\n\ntype DigitProps = {\n  filled: boolean;\n  selected: boolean;\n};\n\nconst Digit: React.FC<DigitProps> = ({ filled, selected }) => (\n  <div\n    className={styles.digit}\n    aria-hidden=\"true\"\n    data-filled={filled ? \"\" : undefined}\n    data-selected={selected ? \"\" : undefined}\n  />\n);\n\ntype MFAProps = {\n  className?: string;\n  length?: number;\n  disabled?: boolean;\n} & Omit<\n  React.ComponentProps<\"input\">,\n  \"type\" | \"inputMode\" | \"pattern\" | \"autoComplete\"\n>;\n\nexport const MFAInput = forwardRef(function MFAInput(\n  { className, length = 6, ...props }: PropsWithoutRef<MFAProps>,\n  ref: React.ForwardedRef<HTMLInputElement>,\n) {\n  const classes = classNames(styles.container, className);\n  const [currentLength, setCurrentLength] = React.useState(0);\n  const [selection, setSelection] = React.useState<null | [number, number]>(\n    null,\n  );\n\n  const update = (event: React.SyntheticEvent<HTMLInputElement>) => {\n    const input = event.currentTarget;\n    setCurrentLength(input.value?.length);\n\n    if (\n      document.activeElement !== input ||\n      input.selectionStart === null ||\n      input.selectionEnd === null\n    ) {\n      setSelection(null);\n    } else {\n      setSelection([input.selectionStart, input.selectionEnd]);\n    }\n  };\n\n  return (\n    <div className={classes}>\n      <input\n        {...props}\n        inputMode=\"numeric\"\n        // Showing digits on mobile browsers. Using numbers is not really suited\n        // as it often adds a way to increment or decrement the current value\n        // which is not interesting for this use case\n        type=\"text\"\n        minLength={0}\n        maxLength={length}\n        className={styles.control}\n        pattern={`\\\\d{${length}}`}\n        autoComplete=\"one-time-code\"\n        onSelect={update}\n        onFocus={update}\n        onBlur={update}\n        onMouseDown={update}\n        onMouseMove={update}\n        onMouseUp={update}\n        onChange={update}\n        ref={ref}\n      />\n      {Array.from(Array(length).keys()).map((index) => (\n        <Digit\n          key={index}\n          filled={index < currentLength}\n          selected={\n            !!selection && index >= selection[0] && index < selection[1]\n          }\n        />\n      ))}\n    </div>\n  );\n});\n\nexport const MFAControl = forwardRef<\n  ComponentRef<typeof MFAInput>,\n  ComponentProps<typeof MFAInput>\n>(function ActionControl(props, ref) {\n  return (\n    <Control asChild>\n      <MFAInput ref={ref} {...props} />\n    </Control>\n  );\n});\n"],"names":["PayloadType","MSC4108SignInWithQR","checkCode","_this$channel","this","channel","getCheckCode","constructor","didScanCode","client","onFailure","_defineProperty","ourIntent","QrCodeMode","Reciprocate","Login","code","_code","generateCode","getDomain","isExistingDevice","isNewDevice","negotiateProtocols","logger","info","connect","_oidcClientConfig","oidcClientConfig","issuer","getAuthIssuer","discoverAndValidateOIDCIssuerWellKnown","e","error","metadata","grant_types_supported","includes","DEVICE_CODE_SCOPE","send","type","Failure","reason","MSC4108FailureReason","UnsupportedProtocol","RendezvousError","Protocols","protocols","homeserver","payload","receive","UnexpectedMessageReceived","serverName","deviceAuthorizationGrant","Error","Protocol","protocol","isDeviceAuthorizationGrantProtocolPayload","device_authorization_grant","dag","device_id","expectingNewDeviceId","verification_uri","verificationUri","verification_uri_complete","verificationUriComplete","deviceAlreadyExists","_this$client","getDevice","err","MatrixError","httpStatus","DeviceAlreadyExists","shareSecrets","Success","Secrets","secrets","ProtocolAccepted","Declined","ClientRendezvousFailureReason","UserDeclined","timeout","Date","now","_this$client2","secretsBundle","getCrypto","exportSecretsBundle","cancelled","UserCancelled","_objectSpread","sleep","DeviceNotFound","secureReceive","secureSend","declineLoginOnExistingDevice","cancel","_this$onFailure","call","close","message","super","RendezvousIntent","MSC4108RendezvousSession","fetchFn","url","fallbackRzServer","ready","_ready","_cancelled","fetch","resource","options","globalThis","getPostEndpoint","doesServerSupportUnstableFeature","http","getUrl","undefined","ClientPrefix","Unstable","toString","warn","data","_this$url","_res$headers$get","method","Method","Put","Post","uri","headers","etag","res","body","redirect","status","Unknown","get","expires","expiresTimer","clearTimeout","expiresAt","setTimeout","Expired","getTime","json","_poll$headers$get","poll","Get","ETagMissing","text","Delete","MSC4108SecureChannel","rendezvousSession","theirPublicKey","secureChannel","Ecies","mode","QrCodeData","public_key","toBytes","_this$establishedChan","x","establishedChannel","check_code","Array","from","as_bytes","map","b","join","connected","result","establish_outbound_channel","initial_message","ciphertext","decrypt","InsecureChannelDetected","loginInitiateMessage","candidateLoginInitiateMessage","establish_inbound_channel","loginOkMessage","encrypt","plaintext","stringifiedPayload","JSON","stringify","debug","parse","Digit","filled","selected","jsx","className","styles","MFAInput","forwardRef","_ref","ref","length","props","_objectWithoutProperties","_excluded","classes","classNames","currentLength","setCurrentLength","React","selection","setSelection","update","event","_input$value","input","currentTarget","value","document","activeElement","selectionStart","selectionEnd","jsxs","children","inputMode","minLength","maxLength","pattern","autoComplete","onSelect","onFocus","onBlur","onMouseDown","onMouseMove","onMouseUp","onChange","keys","index"],"sourceRoot":""}